mysql 索引优化,索引建立原则和不走索引的原因

第一:选择唯一性索引

唯一性索引的值是唯一的,可以更快捷的通过该索引来确定某条记录.

2.索引的列为where 后面经常作为条件的字段建立索引

如果某个字段经常作为查询条件,而且又有较少的重复列或者是唯一咧可以考虑作为索隐列

经常作为查询条件的列作为索引会提高速度

3.位经常需要进行排序.分组和联合操作的的字段建立索引.

order by  group by  distinct union

这种情况下在查询的时候排序会浪费很多的时间,

如果为其建立索引可以有效的避免排序操作.

4.限制索引的的数目,索引的数目多,对系统的资源也是一种消耗,删除修改也会费资源.

5.劲量使用数据量少的索引. 或者索引前缀索引.

如果索引的值很长, 查询速度就会受到影响.

6．尽量使用前缀来索引
如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索
会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

7.删除不再使用的索引.数据或者业务变更,数据方式变更就需要,删除无用的索引.

8.小表不应该建立索引.

这篇文章主要记录，我对如何找未使用索引的理解及风险(目前还未找到理想方法)，能像oracle保存执行计划，根据执行计划(v$sql_plan)来判断索引使用情况是
比较安全。当然oracle的index monitor特性类似percona的userstat有比较大的风险。

   以下四个工具(方法)是在mysql找未使用索引比较方便，但都存在一定风险

   1、mysqlidxchx

   2、pt-index-usage

   3、userstat

   4、check-unused-keys

   1、mysqlidxchx工具很长时间没有更新，但主要用来分析general log、slow.log，来判断实例中那个索引是可以删除，但这个工具没有经过实战，风险很大。

   2、pt-index-usage原理来类似mysqlidxchx，执行过程中性能消耗比较严重，如果要在生产库上部署，最好在凌晨业务低锋时使用，pt-index-usage只
   支持slow.log格式的文件，如果要全面分析整个实例索引使用情况，需要long_query_time设置成0，才能把所以的sql记录下来，但同时会对磁盘空间造成压力，
   同时pt-index-usage对大文件分析就是件痛苦的事。当然pt-index-usage可以考虑部分表索引使用情况的确认。

   3、最看好的userstat，收集信息性能优越，成本低。这个patch是google贡献的(userstat_running)，percona把它改名成userstat，默认是不开启的，
   开启是会收集客户端、索引、表、线程信息存储在CLIENT_STATISTICS、INDEX_STATISTICS、TABLE_STATISTICS、THREAD_STATISTICS。Userstat
   的bug导致的问题太严重，直接导致mysql crash，到目前淘宝生产环境还没有使用。

   4、Ryan Lowe的check-unused-keys脚本基于userstat，能够比较方便输出需要删除的索引。

   小结：mysql能把每条sql执行计划保存在性能视图中，写入性能视图成本是非常小，用户可以根据执行计划来判断索引使用情况，分析执行计划突变的监控。

=-=======================================================================================================================

简单记忆建议索引的原则是 :唯一列 经常被查询   排序 预先建立索引    总体控制数量   使用字段少的列索引  前缀索引   删除无用 小表不建

=========================================================================================================================

不走索引的原因:

1.没有查询条件没where 后面的内容  查询条件没索引

2.查询条件没引导列.  没有有索引的列

3.查询数量是超过表的一部分,mysql30%,oracle 20%

4.索引失效,索引插入过多可能发生意外失效

5.查询条件使用函数在索隐列上面.计算等.

查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等)
错误的例子：select * from test where id-1=9; 正确的例子：select * from test where id=10;

6.对小表查询

7.统计数据不真实.

8.CBO计算走索引花费过大的情况

9查询条件字符串和数字等的隐式转换.

10.!= <> 

11.%% 两个百分号不走索引,开始的结尾的百分号走索引.

14 not in    not exist             in 劲量转换为union

15, time 和date 时间格式不一致

 

16.17,B-tree索引is null不会走,is not null会走,位图索引 is null,is not null 都会走

索隐列避免空列,一般选非空的列.


===============================================================

MyISAM 存储引擎索引键长度总和不能超过1000 字节；
BLOB 和TEXT 类型的列只能创建前缀索引；
MySQL 目前不支持函数索引；
使用不等于（!= 或者<>）的时候MySQL 无法使用索引；
过滤字段使用了函数运算后（如abs(column)），MySQL 无法使用索引；
Join 语句中Join 条件字段类型不一致的时候MySQL 无法使用索引；
使用LIKE 操作的时候如果条件以通配符开始（ '%abc...'）MySQL 无法使用索引；
使用非等值查询的时候MySQL 无法使用Hash 索引；
在我们使用索引的时候，需要注意上面的这些限制，
尤其是要注意无法使用索引的情况，因为这很容易让我们因为疏忽而造成极大的性能隐患。


mysql 不走索引的情况
1 or (待确认)、in（待确认）

2 like '%abc' 或者 like‘%abc%’

3 where num/2=100 或者 subString(a,1,3)='ab'

4 where id !=2 或者 where id <> 2

5 where name is null

6 复合索引a-b-c,a用到，b用不到，c用不到，ab有效，ba有效，a or b无效，ac有效，bc无效，abc有效
联合索引本质：
当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引
想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！

在最左匹配原则中，有如下说明：
1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3
and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。


 https://blog.csdn.net/Abysscarry/article/details/80792876

7 Mysql复合索引，条件中有or时使用不到  https://blog.csdn.net/u010002184/article/details/85195328



原文地址：https://blog.csdn.net/Abysscarry/article/details/80792876

三、结论
通俗理解：
利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿
首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，
电话簿将没有用处。

所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引
则没有用处。

重点：

多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引！

最左前缀原则：

顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上，
注：如果第一个字段是范围查询需要单独建一个索引
注：在创建联合索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。这样的话扩展性较好，比如 userid 经常需要作为查询条件，而 mobile 
不常常用，则需要把 userid 放在联合索引的第一位置，即最左边

同时存在联合索引和单列索引（字段有重复的），这个时候查询mysql会怎么用索引呢？

这个涉及到mysql本身的查询优化器策略了，当一个表有多条索引可走时, Mysql 根据查询语句的成本来选择走哪条索引；

有人说where查询是按照从左到右的顺序，所以筛选力度大的条件尽量放前面。网上百度过，很多都是这种说法，但是据我研究，mysql执行优化器会对其进行优化，
当不考虑索引时，where条件顺序对效率没有影响，真正有影响的是是否用到了索引！

联合索引本质：

当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引
想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！
注：这个可以结合上边的 通俗理解 来思考！

其他知识点：

1、需要加索引的字段，要在where条件中
2、数据量少的字段不需要加索引；因为建索引有一定开销，如果数据量小则没必要建索引（速度反而慢）
3、如果where条件中是OR关系，加索引不起作用
4、联合索引比对每个列分别建索引更有优势，因为索引建立得越多就越占磁盘空间，在更新数据的时候速度会更慢。另外建立多列索引时，顺序也是需要注意的，
应该将严格的索引放在前面，这样筛选的力度会更大，效率更高。

