
本文链接：https://blog.csdn.net/baidu_37964071/article/details/80303465
一、TCP协议的特点
TCP全称为 “传输控制协议”(Transmission Control Protocol)，顾名思义， 要对数据的传输进行一个详细的控制。有如下特点：
1、面向连接的
2、面向字节流
3、保证可靠传输(丢包重发,超时重传)
4、支持全双工通信
5、支持端口到端口的连接，每一条TCP连接只能有两个端点

二、TCP协议段格式
如下图：

解释各字段的意思:
1、源/目的端口号: 表示数据是从哪个进程来, 到哪个进程去；
2、32位序号/32位确认号:相互协同，保证可靠性，保证按序到达。
3、4位TCP报头长度: 表示该TCP头部有多少个32位bit(有多少个4字节); 所以TCP头部最大长度是15 * 4 = 60
4、6位标志位:
URG: 紧急指针是否有效
ACK: 确认号是否有效
PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走
RST: 对方要求重新建立连接，我们把携带RST标识的称为复位报文段
SYN: 请求建立连接，我们把携带SYN标识的称为同步报文段
FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段
5、16位窗口大小:自己的接收缓冲区大小（下文流量控制有讲解）
6、6位校验和: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题. 此处的检验和不光包含TCP首部, 也包含TCP数据部分.
7、16位紧急指针: 标识哪部分数据是紧急数据。

三、TCP的连接建立
1、三次握手
过程如下：

解析：
（1）服务端状态转化:
[CLOSED->LISTEN]：服务器端调用listen后进入LISTEN状态, 等待客户端连接。[LISTEN->SYN_RCVD]：一旦监听到连接请求(同步报文段)，就将该连接放
入内核等待队列中, 并向客户端发送SYN确认报文。
[SYN_RCVD -> ESTABLISHED]：服务端一旦收到客户端的确认报文, 就进入ESTABLISHED状态, 可以进行读写数据了。
（2）客户端状态转化:
[CLOSED -> SYN_SENT]：客户端调用connect, 发送同步报文段;
[SYN_SENT -> ESTABLISHED]：connect调用成功, 则进入ESTABLISHED状态, 开始读写数据。

2、四次挥手
注意，断开连接是双方的问题，必须经过双方同意。
过程如下：

解析：
（1）服务端状态转化:
[ESTABLISHED -> CLOSE_WAIT]：当客户端主动关闭连接(调用close), 服务器会收到结束报文段，服务器返回确认报文段并进入CLOSE_WAIT；
[CLOSE_WAIT -> LAST_ACK]：进入CLOSE_WAIT后说明服务器准备关闭连接(需要处理完之前的数据); 当服务器真正调用close关闭连接时, 会向客户端发
送FIN, 此时服务器进入LAST_ACK状态, 等待最后一个ACK到来(这个ACK是客户端确认收到了FIN) [LAST_ACK -> CLOSED]：服务器收到了对FIN的ACK, 
彻底关闭连接。
（2）客户端状态转化:
[ESTABLISHED -> FIN_WAIT_1]： 客户端主动调用close时, 向服务器发送结束报文段, 同时进入 FIN_WAIT_1;
[FIN_WAIT_1 -> FIN_WAIT_2]：客户端收到服务器对结束报文段的确认, 则进入FIN_WAIT_2, 开始等待服务器的结束报文段;
[FIN_WAIT_2 -> TIME_WAIT]：客户端收到服务器发来的结束报文段, 进入TIME_WAIT, 并发出 LAST_ACK;
[TIME_WAIT -> CLOSED]：客户端要等待一个2MSL的时间, 才会进入CLOSED状态
注:TCP协议规定,主动关闭连接的一方要处于TIME_WAIT状态,等待两个MSL(maximum segment lifetime)的时间后才能回到CLOSED状态，原因在下文。

3、释放连接2MSL问题
MSL，指的是报文最大生存时间，也就是指报文从A端到B端单向的最大传输时间。
那等待2MSL的原因是什么呢？
（1）保证在两个传输方向上的尚未被接收或迟到的报文段都已经消失。
客户机发送完ACK报文段，经过2MSL时间后，本次连接持续时间内所产生的所有的报文段都从网络当中消失。这样就可以使得下一个新的连接中不会出现这种旧的
连接请求报文段。
（2）保证四次挥手的时候客户机发送的最后一个ACK报文段能够到达服务器。
假设丢失了，此时服务器会再重发一个 FIN。这时虽然客户端的进程不在了, 但是TCP连接还在, 仍然可以重发LAST_ACK)；
然后客户机重传一次ACK确认报文段，重新启动时间2MSL等待定时器，这样才能确保客户机和服务器都进入CLOSED状态，防止因为客户机的ACK报文段的丢失导
致服务器无法CLOSED。

4、常见问题
（1）为什么要采用三次握手，二次握手可以吗?
采用三次握手是为了防止已连接的请求报文段又传送到服务器，造成服务器崩溃。
假设只有两次握手，连接时，第二次丢失，服务器认为连接成功，而客户端认为连接失败，继续发送连接请求，服务器就会收到SYN的洪水攻击。
（2）为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
因为TCP是全双工模式，因此每个方向都需要一个FIN和ACK，当一端发送了FIN包之后，处于半关闭状态，此时仍然可以接收数据包。
在建立连接时，服务器可以把SYN和ACK放在一个包中发送。
假设在断开连接时，如果一端收到FIN包，但此时仍有数据未发送完，此时就需要先向对端回复FIN包的ACK。等到将剩下的数据都发送完之后，才能向对端发送FIN，
断开这个方向的连接。
因此很多时候FIN和ACK需要在两个数据包中发送，则需要四次握手。

四、TCP协议的可靠性
1、校验和
2、序列号(按序到达)
3、确认应答（ACK）机制
TCP将每个字节的数据都进行了编号，即为序列号，每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据，下一次你从哪里开始发。
举例如下：

4、超时重传机制
传输数据时，可能会出现如下问题：
（1）主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B;
（2）主机A在一个特定时间间隔内没有收到B发来的确认应答, 会进行重发。
（主机A未收到B发来的确认应答, 也可能是因为ACK丢失了）
解决方法：
这样的话，主机B就会收到很多重复数据，TCP协议需要能够识别出那些包是重复的包, 并且把重复的丢弃掉，可以利用前面提到的序列号, 很容易做到去重的效果。

那么, 超时的时间长短如何确定?
可能有人会说, 找到一个最小的时间, 保证 “确认应答一定能在这个时间内返回”。
但是传输的时间，随着网络环境的不同, 是有差异的。
TCP为了保证无论在任何环境下都能比较高性能的通信, 会动态计算这个最大超时时间.。
（1）Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是500ms的整数倍.
（2）如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传.
（3）如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增.
（4）累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接。
5、流量控制
可能会遇到如下问题：
如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送, 就会造成丢包, 继而引起丢包重传等一系列连锁反应。
我们就需要流量控制机制，
（1）当接受方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失
（2）通过窗口来控制 （窗口大小字段越大, 说明网络的吞吐量越高）
所以，简单来说，就是接收方处理不过来数据的时候，就把窗口缩小,并把窗口值告诉发送端。
那么接收端如何把窗口大小告诉发送端呢?
在第一点讲解TCP首部中, 有一个16位窗口字段, 就是存放了窗口的大小信息。
6、拥塞控制
如果在刚连接好的阶段就发送大量的数据, 可能引发问题。
因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵。在不清楚当前网络状态下, 贸然发送大量的数据, 是很有可能引起网络拥塞的。
慢启动原理：
1）当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞
2）比较好的方法是试探一下，即从小到大逐渐增大发送端的拥塞控制窗口数值
3）通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。
（4）在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另
外一个变量–慢开始门限ssthresh
拥塞控制具体过程为：
1）TCP连接初始化，将拥塞窗口设置为1
2）执行慢开始算法，cwind按指数规律增长，直到cwind == ssthress开始执行拥塞避免算法，cwnd按线性规律增长
3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。

五、TCP协议的性能
提高性能:
1、滑动窗口
通过上文我们知道，对每一个发送的数据段，都要给一个ACK确认应答。收到ACK后再发送下一个数据段。
如下：

这样做有一个比较大的缺点, 就是性能较差。
那我们可以一次发送多条数据， 就可以大大提高性能(其实是将多个段的等待时间重叠在一起了)。
如下：

窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。
如上图，上图的窗口大小就是4000个字节 (四个段).
(1)发送前四个段的时候, 不需要等待任何ACK, 直接发送;
(2) 收到第一个ACK后, 滑动窗口向后移动, 继续发送第五个段的数据;
(3) 依次类推;
(4）操作系统内核为了维护这个滑动窗口, 需要开辟发送缓冲区来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉;
窗口越大, 则网络的吞吐率就越高。
那么？丢包了如何进行重传？分两种情况。
（1）数据包已经抵达, ACK被丢了.

这种情况下, 部分ACK丢了并不要紧, 因为可以通过后续的ACK进行确认。
当后续的ACK被收到证明前面的数据包已经抵达。
（2）数据包丢了.

由图可知，当某一段报文段丢失之后, 发送端会一直收到 1001 这样的ACK, 就像是在提醒发送端 “我想要的是 1001” 一样;
如果发送端主机连续三次收到了同样一个 “1001” 这样的应答, 就会将对应的数据 1001 - 2000 重新 发送; 这个时候接收端收到了 1001 之后, 再次
返回的ACK就是7001了(因为2001 - 7000)接收端其实之前 就已经收到了, 被放到了接收端操作系统内核的接收缓冲区中。
* 这种机制被称为 “高速重发控制”(也叫 “快重传”).*
2、快速重传
3、延迟应答
我们都知道，窗口越大, 网络吞吐量就越大, 传输效率就越高.
所以我们应该在保证网络不拥塞的情况下尽量提高传输效率。
举例如下：
假设接收端缓冲区为1M，一次收到了500K的数据; 如果立刻应答, 返回的窗口就是500K;
但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了; 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些, 
也能处理过来;
如果接收端稍微等一会再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M;
延迟应答也有限制：
（1）数量限制: 每隔N个包就应答一次;
（2）时间限制: 超过最大延迟时间就应答一次;
具体的数量和超时时间, 依操作系统不同也有差异; 一般N取2, 超时时间取200ms;

4、捎带应答
在延迟应答的基础上,很多情况下, 客户端服务器在应用层也是 “一发一收” 的。
顾名思义，捎带应答意味着客户端给服务器发送消息, 服务器也会给客户端回一个 消息。那么这个时候ACK就可以搭顺风车, 和服务器回应的消息一起回给客户端。
————————————————
版权声明：本文为CSDN博主「honeyRJ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/baidu_37964071/article/details/80303465

