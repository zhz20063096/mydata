一、前言
为什么调研MongoDB？
  下图是DB-Engines2017年8月数据库的排名统计，可以看到MongoDB总排名在第5，在Nosql数据库中排名第1。

描述

优点：
1）社区活跃，用户较多，应用广泛。
2）MongoDB在内存充足的情况下数据都放入内存且有完整的索引支持，查询效率较高。
3）MongoDB的分片机制，支持海量数据的存储和扩展。
缺点：
1）不支持事务
2）不支持join、复杂查询
初步调研下来，MongoDB具备我们需要的特性，而缺点不影响我们的应用场景，故接下来我们就开始做实际的性能压测。

二、压测性能对比
1、准备条件
1）Mysql 、MongoDB数据库所在服务器硬件环境
这里写图片描述

2）最新的数据库版本
MongoDB server version: 3.4.5
MongoDB client version: mongo-java-driver-2.14.3
Mysql server version:5.6.34
Mysql connector version: mysql-connector-java-6.0.6
MongoDB使用的储存引擎wiredTiger
Mysql使用的储存引擎InnoDB

3）数据库表结构及索引
MongoDB索引为dateTime 且是唯一索引。我们实际测试使用的MongoDB数据结构及字段如图所示。
这里写图片描述

Mysql索引为DATETIME,PARTNER_ID,GOODS_ID,SCOPE且是唯一索引。我们实际测试使用的Mysql数据结构及字段如图所示。

这里写图片描述

sql语句根据datetime字段进行时间范围的查询

4）连接池最大连接数都设置为200个。sql语句调到最优


原文地址：https://www.cnblogs.com/xiaoxi-3-/p/8872511.html

MongoDB和MySQL的区别
前言：
MySQL与MongoDB都是开源的常用数据库，但是MySQL是传统的关系型数据库，MongoDB则是非关系型数据库，也叫文档型数据库，是一种NoSQL的数据库。它们各有各的优点，关键是看用在什么地方。所以我们所熟知的那些SQL语句就不适用于MongoDB了，因为SQL语句是关系型数据库的标准语言。

一、关系型数据库-MySQL
1、在不同的引擎上有不同的存储方式。
2、查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。
3、开源数据库的份额在不断增加，mysql的份额页在持续增长。
4、缺点就是在海量数据处理的时候效率会显著变慢。

二、非关系型数据库-MongoDB
非关系型数据库(nosql ),属于文档型数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性，呈现分层的树状数据结构。数据结构由键值(key=>value)对组成。

1、存储方式：虚拟内存+持久化。
2、查询语句：是独特的MongoDB的查询方式。
3、适合场景：事件的记录，内容管理或者博客平台等等。
4、架构特点：可以通过副本集，以及分片来实现高可用。
5、数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。
6、成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。

三、MongoDB优势与劣势
优势：
1、在适量级的内存的MongoDB的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。
2、MongoDB的高可用和集群架构拥有十分高的扩展性。
3、在副本集中，当主库遇到问题，无法继续提供服务的时候，副本集将选举一个新的主库继续提供服务。
4、MongoDB的Bson和JSon格式的数据十分适合文档格式的存储与查询。
劣势：
1、 不支持事务操作。MongoDB本身没有自带事务机制，若需要在MongoDB中实现事务机制，需通过一个额外的表，从逻辑上自行实现事务。
2、 应用经验少，由于NoSQL兴起时间短，应用经验相比关系型数据库较少。
3、MongoDB占用空间过大。

四、对比
数据库	MongoDB	MySQL
数据库模型	非关系型	关系型
存储方式	以类JSON的文档的格式存储	不同引擎有不同的存储方式
查询语句	MongoDB查询方式（类似JavaScript的函数）	SQL语句
数据处理方式	基于内存，将热数据存放在物理内存中，从而达到高速读写	不同引擎有自己的特点
成熟度	新兴数据库，成熟度较低	成熟度高
广泛度	NoSQL数据库中，比较完善且开源，使用人数在不断增长	开源数据库，市场份额不断增长
事务性	仅支持单文档事务操作，弱一致性	支持事务操作
占用空间	占用空间大	占用空间小
join操作	MongoDB没有join	MySQL支持join
 

2、百万、千万级别的下不同查询量不同并发量的压测结果
  数据库表中记录数总量在百万、千万级别的压测数据及结果如表所示。

这里写图片描述

3、亿级别的下不同查询量不同并发量的压测结果
数据库表中记录数总量在亿级别的压测数据及结果如表所示。

这里写图片描述

压测结果分析：
1）当每次查询数据量在500条时，无论表中数据总量千万或者亿级别，Mysql和MongoDB在100线程并发的情况下查询性能相当，表现良好，平均响应时间在500ms以内，
TPS在230左右。
2）当每次查询数据量在5000条时，表中数据总量为千万级别时，MongoDB在50线程并发情况下查询性能不及Mysql 的一半，100线程并发情况查询性能都很差，平均
响应时间在4500ms左右，表中数据总量为亿级别时，在50个及以上的并发情况下，MongoDB和Mysql性能都较差。
  在本案例简单数据模型下的时间范围内的等值查询应用场景下，MongoDB在高并发条件下的大数据量查询性能并没有比Mysql更好。另外还有一点需要注意的是，在
  本案例中，数据总量由百万级别到千万级别再到亿级别的变化过程中，对于查询性能的影响都不是很大，但对于查询数据量的数倍增长却十分敏感，所以在考量数据库
  查询性能的时候，也要重点考量应用的单次查询量的需求。
  尽管MongoDB在我们的这种应用场景下并没有达到我们预期的性能，我们也简单的调研了下Mysql和MongoDB对于内存的使用机制以及一些可能影响查询效率的内部配置。

三、Mysql和MongoDB内存结构
1、InnoDb内存使用机制
  Innodb体系结构如图所示。

这里写图片描述

  压测的Mysql使用的是Innodb存储引擎，Innodb关于查询效率有影响的两个比较重要的参数分别是innodb_buffer_pool_size，innodb_read_ahead
  _threshold。
  innodb_buffer_pool_size指的是Innodb缓冲池的大小，本例中Innodb缓冲池大小为20G，该参数的大小可通过命令指定innodb_buffer_pool_size 20G。
  缓冲池使用改进的LRU算法进行管理，维护一个LRU列表、一个FREE列表，FREE列表存放空闲页，数据库启动时LRU列表是空的，当需要从缓冲池分页时，首先从
  FREE列表查找空闲页，有则放入LRU列表，否则LRU执行淘汰，淘汰尾部的页分配给新页。
  innodb_read_ahead_threshold相对应的是数据预加载机制，innodb_read_ahead_threshold 30表示的是如果一个extent中的被顺序读取的page超过
  或者等于该参数变量的，Innodb将会异步的将下一个extent读取到buffer pool中，比如该参数的值为30，那么当该extent中有30个pages被sequentially
  的读取，则会触发innodb linear预读，将下一个extent读到内存中；在没有该变量之前，当访问到extent的最后一个page的时候，Innodb会决定是否将
  下一个extent放入到buffer pool中；可以在Mysql服务端通过show innodb status中的Pages read ahead和evicted without access两个值来
  观察预读的情况：
Innodb_buffer_pool_read_ahead：表示通过预读请求到buffer pool的pages；
Innodb_buffer_pool_read_ahead_evicted：表示由于请求到buffer pool中没有被访问，而驱逐出内存的页数。

  可以看出来，Mysql的缓冲池机制是能充分利用内存且有预加载机制，在某些条件下目标数据完全在内存中，也能够具备非常好的查询性能。

2、MongoDB的存储结构及数据模型
1）本例中MongoDB使用的储存引擎是WiredTiger，WiredTiger的结构如图所示。

这里写图片描述

WiredTiger Cache的实现原理图如图所示。

这里写图片描述

  Wiredtiger的Cache采用Btree的方式组织，每个Btree节点为一个page，root page是btree的根节点，internal page是btree的中间索引节点，leaf
  page是真正存储数据的叶子节点；btree的数据以page为单位按需从磁盘加载或写入磁盘。
可以通过在配置文件中指定storage.wiredTiger.engineConfig.cacheSizeGB参数设定引擎使用的内存量。此内存用于缓存工作集数据（索引、namespace，
未提交的write，query缓冲等）。

2）数据模型

内嵌
  MongoDB的文档是无模式的，所以可以支持各种数据结构，内嵌模型也叫做非规格化模型（denormalized）。在MongoDB中，一组相关的数据可以是一个文档，
  也可以是组成文档的一部分。

这里写图片描述
  内嵌类型支持一组相关的数据存储在一个文档中，这样的好处就是，应用程序可以通过比较少的的查询和更新操作来完成一些常规的数据的查询和更新工作。
当遇到以下情况的时候，我们应该考虑使用内嵌类型：
  如果数据关系是一种一对一的包含关系，例如下面的文档，每个人都有一个contact字段来描述这个人的联系方式。像这种一对一的关系，使用内嵌类型可以很方
  便的进行数据的查询和更新。

{
  ”_id”: ,
  ”name”: “Wilber”,
  ”contact”: {
     “phone”: “12345678”,
     “email”: “wilber@shanghai.com”
   }
}

  如果数据的关系是一对多，那么也可以考虑使用内嵌模型。例如下面的文档，用posts字段记录所有用户发布的博客。在这中情况中，如果应用程序会经常通过
  用户名字段来查询改用户发布的博客信息。那么，把posts作为内嵌字段会是一个比较好的选择，这样就可以减少很多查询的操作。

{
   “_id”: ,
   “name”: “Wilber”,
   “contact”: {
    ”phone”: “12345678”,
    ”email”: “wilber@shanghai.com”
  },
  ”posts”: [
  {
    ”title”: “Indexes in MongoDB”,
    ”created”: “12/01/2014”,
    ”link”: “www.linuxidc.com”
  },
  {
    ”title”: “Replication in MongoDB”,
    ”created”: “12/02/2014”,
    ”link”: “www.linuxidc.com”
  },
  {
    ”title”: “Sharding in MongoDB”,
    ”created”: “12/03/2014”,
    ”link”: “www.linuxidc.com”
  }
 ]
}

  根据上面的描述可以看出，内嵌模型可以给应用程序提供很好的数据查询性能，因为基于内嵌模型，可以通过一次数据库操作得到所有相关的数据。同时，内嵌模型
  可以使数据更新操作变成一个原子写操作。然而，内嵌模型也可能引入一些问题，比如说文档会越来越大，这样就可能会影响数据库写操作的性能，还可能会产生数
  据碎片（data fragmentation）。

引用
  相对于嵌入模型，引用模型又称规格化模型（Normalized data models），通过引用的方式来表示数据之间的关系。这里同样使用来自MongoDB文档中的图片，
  在这个模型中，把contact和access从user中移出，并通过user_id作为索引来表示他们之间的联系。

这里写图片描述

当我们遇到以下情况的时候，就可以考虑使用引用模型了：
  使用内嵌模型往往会带来数据的冗余，却可以提升数据查询的效率。但是，当应用程序基本上不通过内嵌模型查询，或者说查询效率的提升不足以弥补数据冗余带
  来的问题时，我们就应该考虑引用模型了。
  当需要实现复杂的多对多关系的时候，可以考虑引用模型。比如我们熟知的例子，学生-课程-老师关系，如果用引用模型来实现三者的关系，可能会比内嵌模型更
  清晰直观，同时会减少很多冗余数据。
  当需要实现复杂的树形关系的时候，可以考虑引用模型。

四、应用场景分析
1、MongoDB的应用场景
1）表结构不明确且数据不断变大
MongoDB是非结构化文档数据库，扩展字段很容易且不会影响原有数据。内容管理或者博客平台等，例如圈子系统，存储用户评论之类的。
2）更高的写入负载
MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。本身存的就是json格式数据。例如做日志系统。
3）数据量很大或者将来会变得很大
Mysql单表数据量达到5-10G时会出现明细的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展，MongoDB内建了sharding、很多数据分片的特性，容易
水平扩展，比较好的适应大数据量增长的需求。
4）高可用性
自带高可用，自动主从切换（副本集）

不适用的场景
1）MongoDB不支持事务操作，需要用到事务的应用建议不用MongoDB。
2）MongoDB目前不支持join操作，需要复杂查询的应用也不建议使用MongoDB。

2、关系型数据库和非关系型数据库的应用场景对比
关系型数据库适合存储结构化数据，如用户的帐号、地址：
1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹
2）这些数据的规模、增长的速度通常是可以预期的
3）事务性、一致性
　　
NoSQL适合存储非结构化数据，如文章、评论：
1）这些数据通常用于模糊处理，如全文搜索、机器学习
2）这些数据是海量的，而且增长的速度是难以预期的，
3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性
4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差

